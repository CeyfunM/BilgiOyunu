<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <title>Bilgi K√ºresi ‚Äî √úlkeleri Bul</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 600px at 70% -10%, #0b132b 0%, #000814 60%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: #e6edf3;
      overflow: hidden;
    }
    #scene {
      position: absolute;
      inset: 0;
    }
    .hud {
      position: fixed;
      top: 12px;
      left: 12px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      z-index: 10;
      user-select: none;
    }
    .hud .card {
      background: rgba(255,255,255,0.06);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 10px 14px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.25);
    }
    .score { font-weight: 700; letter-spacing: 0.3px; }
    .qno { opacity: 0.85; }
    .btn {
      cursor: pointer;
      background: linear-gradient(135deg, #4cc9f0, #4361ee);
      color: white;
      border: 0;
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 700;
      box-shadow: 0 8px 18px rgba(67,97,238,0.35);
      transition: transform .06s ease, filter .2s ease;
    }
    .btn:active { transform: translateY(1px) scale(0.99); }
    .btn.secondary {
      background: rgba(255,255,255,0.08);
      box-shadow: none;
      border: 1px solid rgba(255,255,255,0.15);
    }
    .question {
      position: fixed;
      left: 50%;
      bottom: 24px;
      transform: translateX(-50%);
      width: min(920px, calc(100% - 24px));
      background: rgba(10, 14, 24, 0.75);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(8px);
      border-radius: 18px;
      padding: 16px 18px;
      z-index: 10;
      box-shadow: 0 12px 28px rgba(0,0,0,0.35);
    }
    .question h2 {
      font-size: clamp(16px, 1.8vw, 20px);
      margin: 0 0 6px 0;
      font-weight: 800;
    }
    .question p {
      margin: 0;
      opacity: 0.95;
      line-height: 1.4;
    }
    .question .actions {
      margin-top: 10px;
      display: flex; gap: 8px; flex-wrap: wrap;
    }
    .toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%,-50%) scale(0.98);
      opacity: 0;
      pointer-events: none;
      z-index: 20;
      padding: 14px 18px;
      border-radius: 14px;
      background: rgba(9, 20, 46, 0.92);
      border: 1px solid rgba(255,255,255,0.16);
      box-shadow: 0 16px 40px rgba(0,0,0,0.5);
      font-weight: 800;
      letter-spacing: .2px;
      transition: opacity .15s ease, transform .15s ease;
      white-space: nowrap;
    }
    .toast.show {
      opacity: 1; transform: translate(-50%,-50%) scale(1);
    }
    .legend {
      position: fixed;
      right: 12px;
      top: 12px;
      z-index: 10;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 12px;
    }
    .legend .row { display:flex; align-items:center; gap:8px; margin: 6px 0; }
    .dot { width: 14px; height: 14px; border-radius: 50%; display:inline-block; }
    .dot.sel { background:#ffd166; }
    .dot.true { background:#06d6a0; }
    .dot.hilite { background:#f94144; }
    .overlay {
      position: absolute; inset: 0; backdrop-filter: blur(8px);
      background: radial-gradient(500px 350px at 70% -10%, rgba(76,201,240,0.15), rgba(0,0,0,0.6));
      display: grid; place-items: center; z-index: 30;
    }
    .overlay .panel {
      background: rgba(10, 14, 24, 0.85);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 18px; padding: 20px 22px;
      width: min(720px, calc(100% - 24px));
      box-shadow: 0 16px 40px rgba(0,0,0,0.55);
      text-align: center;
    }
    .panel h1 { margin: 0 0 10px 0; font-size: clamp(22px, 3vw, 32px); }
    .panel p { margin: 6px 0; opacity: 0.9; }
    .hidden { display: none; }
    .muted { opacity: .8 }
    a, a:visited { color: #4cc9f0; text-decoration: none; }
  </style>
</head>
<body>
  <div id="scene"></div>

  <div class="hud">
    <div class="card score">Puan: <span id="score">0</span></div>
    <div class="card qno">Soru: <span id="qno">-</span></div>
    <button class="btn secondary" id="skipBtn" title="Soruyu pas ge√ß">Pas Ge√ß</button>
    <button class="btn secondary" id="recenterBtn" title="K√ºreyi ortala">Ortala</button>
  </div>

  <div class="legend">
    <div class="row"><span class="dot sel"></span> Se√ßimin</div>
    <div class="row"><span class="dot true"></span> Doƒüru √úlke</div>
    <div class="row"><span class="dot hilite"></span> Yanƒ±t sonrasƒ± vurgulanan √ºlke</div>
  </div>

  <div class="question" id="questionBox">
    <h2 id="questionText">Hazƒ±rlanƒ±yor‚Ä¶</h2>
    <p class="muted">Haritadaki √ºlkelere tƒ±klayarak cevap ver.</p>
    <div class="actions">
      <button class="btn" id="startBtn">Ba≈üla</button>
    </div>
  </div>

  <div class="overlay" id="startOverlay">
    <div class="panel">
      <h1>Bilgi K√ºresi üåç</h1>
      <p>Kurallarƒ± hatƒ±rlatalƒ±m:</p>
      <p><b>Doƒüru √ºlke</b>: +3 puan ¬∑ <b>Kom≈üu √ºlke</b>: +2 puan ¬∑ <b>Farklƒ± kƒ±ta</b>: +0.5 puan ¬∑ <b>Diƒüer</b>: 0 puan</p>
      <p class="muted">Yanlƒ±≈üsa, k√ºre 2 saniyeliƒüine doƒüru √ºlkeye d√∂ner ve vurgular.</p>
      <div class="actions" style="justify-content:center;margin-top:12px">
        <button class="btn" id="bigStartBtn">Oyuna Ba≈üla</button>
        <button class="btn secondary" id="howBtn">Nasƒ±l oynanƒ±r?</button>
      </div>
      <p id="howText" class="hidden muted" style="margin-top:10px">Soru kutusundaki ipucuna g√∂re k√ºredeki √ºlkeye tƒ±klayƒ±n. 
      Saƒü √ºstteki <b>Ortala</b> ile g√∂r√ºnt√ºy√º sƒ±fƒ±rlayabilir, <b>Pas Ge√ß</b> ile yeni soruya ge√ßebilirsiniz.</p>
      <p class="muted" style="margin-top:10px;font-size:12px">Not: Harita ve k√ºt√ºphaneler i√ßin internet gerekir.</p>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three-globe@2.30.1/dist/three-globe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/controls/OrbitControls.js"></script>

  <script>
  (function(){
    const sceneEl = document.getElementById('scene');
    const qText = document.getElementById('questionText');
    const qnoEl = document.getElementById('qno');
    const scoreEl = document.getElementById('score');
    const startBtn = document.getElementById('startBtn');
    const bigStartBtn = document.getElementById('bigStartBtn');
    const startOverlay = document.getElementById('startOverlay');
    const howBtn = document.getElementById('howBtn');
    const howText = document.getElementById('howText');
    const skipBtn = document.getElementById('skipBtn');
    const recenterBtn = document.getElementById('recenterBtn');
    const toast = document.getElementById('toast');

    let width = window.innerWidth;
    let height = window.innerHeight;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    sceneEl.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, width/height, 0.1, 2000);
    camera.position.z = 280;

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.07;
    controls.minDistance = 160;
    controls.maxDistance = 420;
    controls.enablePan = false;

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(-100, 50, 130);
    scene.add(dirLight);

    // Globe
    const globe = new ThreeGlobe()
      .globeImageUrl('//unpkg.com/three-globe/example/img/earth-blue-marble.jpg')
      .bumpImageUrl('//unpkg.com/three-globe/example/img/earth-topology.png')
      .showGraticules(true)
      .polygonAltitude(0.01)
      .polygonCapColor(feat => {
        if (highlightIds.has(getId(feat))) return 'rgba(249,65,68,0.9)'; // highlight (red-ish)
        if (feat === currentTarget) return 'rgba(6,214,160,0.8)'; // correct country (green)
        if (feat === currentSelection) return 'rgba(255,209,102,0.85)'; // selection (yellow)
        return 'rgba(180,200,235,0.12)'; // default
      })
      .polygonSideColor(() => 'rgba(0,0,0,0.2)')
      .polygonStrokeColor(() => 'rgba(255,255,255,0.15)')
      .onPolygonHover(hoverD => {
        renderer.domElement.style.cursor = hoverD ? 'pointer' : 'default';
      })
      .onPolygonClick(handleClick);

    scene.add(globe);

    // State
    let countries = [];           // raw geojson features (playable)
    let byName = new Map();       // normalizedName -> feature
    let restIndex = new Map();    // normalizedName -> {name, capital, continent}
    let currentTarget = null;
    let currentSelection = null;
    let highlightIds = new Set();
    let score = 0;
    let qno = 0;
    let running = false;

    function showToast(text){
      toast.textContent = text;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 1200);
    }

    function resize(){
      width = window.innerWidth;
      height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width/height;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);

    // Helpers
    const deaccent = (s) => s.normalize('NFD').replace(/\p{Diacritic}/gu,'');
    function normName(s){
      return deaccent(String(s||''))
        .toLowerCase()
        .replace(/&/g,'and')
        .replace(/[(]["‚Äô'a-z \-]+[)]/g,'') // (‚Ä¶)
        .replace(/,.*$/,'') // remove comma stuff like "Congo, Republic of the"
        .replace(/the /g,'')
        .replace(/[^a-z0-9 ]+/g,'')
        .replace(/\s+/g,' ')
        .trim();
    }
    function centroidOf(feat){
      try {
        const c = turf.centroid(feat);
        const [lng, lat] = c.geometry.coordinates;
        return { lat, lng };
      } catch(e){
        // fallback: average of bbox
        const b = turf.bbox(feat);
        const lat = (b[1]+b[3])/2;
        const lng = (b[0]+b[2])/2;
        return { lat, lng };
      }
    }
    function getId(f){ return f && (f.id || f.properties && (f.properties.name || f.properties.NAME || f.properties.ADMIN)); }

    function setQuestion(text){
      qText.textContent = text;
      qnoEl.textContent = qno;
    }

    function nextQuestion(){
      currentSelection = null;
      highlightIds.clear();
      updatePolys();
      qno += 1;
      qnoEl.textContent = qno;

      // pick a random country target
      currentTarget = countries[Math.floor(Math.random()*countries.length)];
      updatePolys();

      const n = getId(currentTarget);
      const norm = normName(n);
      const info = restIndex.get(norm) || {};
      const cap = (info.capital && info.capital[0]) || null;
      const special = specialHints[norm];
      const roll = Math.random();

      let qStr = '';
      if (special && roll < 0.20) { // 20% chance for special hint
        qStr = special;
      } else if (cap && roll < 0.70) { // 50% chance for capital-based (if available)
        qStr = `Ba≈ükenti ${cap} olan √ºlke hangisidir?`;
      } else { // fallback: name directly
        qStr = `Hangi √ºlke? ‚Üí ${n}`;
      }
      setQuestion(qStr);
    }

    function updatePolys(){
      globe.polygonCapColor(globe.polygonCapColor());
      globe.polygonsTransitionDuration(200);
    }

    function spinToCountry(feat, duration=2000){
      const {lat,lng} = centroidOf(feat);
      globe.pointOfView({ lat, lng, altitude: 1.45 }, duration);
    }

    function handleClick(feat, evt, { lat, lng }){
      if (!running || !currentTarget) return;
      currentSelection = feat;
      updatePolys();

      // Evaluate
      const selName = normName(getId(feat));
      const tgtName = normName(getId(currentTarget));
      const selInfo = restIndex.get(selName);
      const tgtInfo = restIndex.get(tgtName);

      const isCorrect = selName === tgtName;

      let gained = 0;
      let msg = '';
      if (isCorrect){
        gained = 3;
        msg = 'Doƒüru! +3 puan üëè';
        showToast(msg);
        score += gained;
        scoreEl.textContent = score.toLocaleString('tr-TR');
        // brief highlight then next
        setTimeout(nextQuestion, 900);
        return;
      }

      // neighbor? (shared border)
      let neighbor = false;
      try {
        neighbor = turf.booleanTouches(currentSelection, currentTarget);
      } catch(e){ neighbor = false; }

      if (neighbor){
        gained = 2;
        msg = '√áok yakƒ±ndƒ±! Kom≈üu √ºlkeyi se√ßtin. +2 puan';
      } else {
        // different continent?
        const selCont = selInfo && selInfo.continent || null;
        const tgtCont = tgtInfo && tgtInfo.continent || null;
        if (selCont && tgtCont && selCont !== tgtCont){
          gained = 0.5;
          msg = 'Farklƒ± kƒ±ta se√ßtin. +0.5 puan';
        } else {
          gained = 0;
          msg = 'Maalesef, puan yok.';
        }
      }

      score += gained;
      scoreEl.textContent = score.toLocaleString('tr-TR');
      showToast(msg);

      // Reveal correct country: highlight + spin 2s
      highlightIds.add(getId(currentTarget));
      updatePolys();
      spinToCountry(currentTarget, 2000);

      // show "Doƒüru cevap: X"
      const trueName = getId(currentTarget);
      setQuestion(`Doƒüru cevap: ${trueName}`);
      setTimeout(() => {
        highlightIds.clear();
        updatePolys();
        nextQuestion();
      }, 2000);
    }

    function startGame(){
      if (running) return;
      running = true;
      startOverlay.classList.add('hidden');
      startBtn.classList.add('hidden');
      qno = 0; score = 0;
      scoreEl.textContent = '0';
      qnoEl.textContent = '-';
      nextQuestion();
    }

    howBtn.addEventListener('click', () => {
      howText.classList.toggle('hidden');
    });
    [startBtn, bigStartBtn].forEach(b => b.addEventListener('click', startGame));
    skipBtn.addEventListener('click', () => { if(running){ nextQuestion(); showToast('Pas ge√ßildi'); }});
    recenterBtn.addEventListener('click', () => globe.pointOfView({ lat: 20, lng: 0, altitude: 2.1 }, 800));

    // Special hints (by normalized country name)
    const specialHints = {
      [normName('Turkey')]: '√únl√º ≈üarkƒ±cƒ± Tarkan\'ƒ±n vatanda≈üƒ± olduƒüu √ºlke hangisi?',
      [normName('Australia')]: 'Kangarusu ile me≈ühur √ºlke hangisi?',
      [normName('Japan')]: 'ƒ∞kinci D√ºnya Sava≈üƒ±\'nda atom bombasƒ± atƒ±lan √ºlke hangisi?'
    };

    // Load data
    Promise.all([
      // World countries GeoJSON (by name)
      fetch('https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson').then(r => r.json()),
      // Country metadata (names, capitals, continents)
      fetch('https://restcountries.com/v3.1/all?fields=name,capital,continents,cca3,ccn3,altSpellings').then(r => r.json())
    ]).then(([world, rest]) => {
      // Build restcountries index
      for (const c of rest){
        const namesToIndex = new Set();
        if (c.name && c.name.common) namesToIndex.add(c.name.common);
        if (c.name && c.name.official) namesToIndex.add(c.name.official);
        (c.altSpellings || []).forEach(s => namesToIndex.add(s));
        // normalized variants
        for (const nm of Array.from(namesToIndex)){
          const key = normName(nm);
          if (!key) continue;
          if (!restIndex.has(key)) {
            restIndex.set(key, {
              name: c.name?.common || nm,
              capital: c.capital || [],
              continent: (c.continents && c.continents[0]) || null
            });
          }
        }
      }

      // Prepare features; drop Antarctica and tiny null-geometry
      const features = world.features.filter(f => f && f.geometry && f.properties && f.properties.name && f.properties.name !== 'Antarctica');
      // enrich ids for consistent access
      features.forEach(f => { f.id = f.properties.name; });

      // Build playable list: only those resolvable to restcountries
      countries = features.filter(f => restIndex.has(normName(f.properties.name)));

      // Map names
      for (const f of countries){ byName.set(normName(f.properties.name), f); }

      // Set data to globe
      globe.polygonsData(countries);

      // initial POV
      recenterBtn.click();

      // ready UI
      qText.textContent = 'Hazƒ±rsan ba≈üla!';
    }).catch(err => {
      console.error(err);
      qText.textContent = 'Veriler y√ºklenemedi. L√ºtfen internet baƒülantƒ±nƒ±zƒ± kontrol edin ve sayfayƒ± yenileyin.';
    });

    // Render loop
    (function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();

  })();
  </script>
</body>
</html>
